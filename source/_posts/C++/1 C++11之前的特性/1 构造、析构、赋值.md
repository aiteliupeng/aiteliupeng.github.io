---
title: 构造、析构、赋值
---

### 编译器对空类做了什么

当我们写下如下代码时，编译器帮我们完成了哪些工作？

```C++
class Empty{};
```

编译器生成的代码，*C\+\+11有所变化，相关内容在C\+\+11分析。*

```C++
class Empty{
    public:
    Empty(){}    // Empty e;  此场景下调用
    ~Empty(){}
    Empty(const Empty& rhs){}    // Empty e2(e);  此场景下调用
    Empty& operator= (const Empty& rhs){}    // e3 = e2;  此场景下调用
};
```

所以，编译器会生成默认构造函数、析构函数、拷贝构造函数和赋值构造函数。

**注意**

* 编译器生成的析构函数没有**virtual**，例外：如果Empty类继承的base类有virtual析构函数，编译器根据继承特性，会生成virtual析构函数。
* 默认拷贝构造函数和赋值构造函数，只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象。
* 默认拷贝构造函数和赋值构造函数，无法对引用成员变量和const成员变量赋值，编译时报错。
* 如果base类中的默认拷贝构造函数和赋值构造函数声明为private，子类不会生成默认拷贝构造函数和赋值构造函数。

### 拒绝编译器生成默认拷贝构造函数和赋值构造函数的方法

*C\+\+11中有更加优雅的方式。*

```C++
class Uncopyable{
    protected:
    Uncopyable(){}
    ~Uncopyable(){}
    private:
    Uncopyable(const Uncopyable&);    // 声明为私有方法，阻止拷贝构造和赋值构造
    Uncopyable& operator= (const Uncopyable&);
};
```

**注意**

* Uncopyable类的实现是protected，继承时需注意，不一定非public不可。
* Uncopyable类的析构函数非virtual。
* Uncopyable类为base class，可能会多重继承。

### 基类析构函数必须声明为virtual

```C++
#include <iostream>

class Base {
    public:
    Base(){ std::cout << "Base()" << std::endl; }
    ~Base(){ std::cout << "~Base()" << std::endl; }
};

class Derived : public Base {
    public:
    Derived(){ std::cout << "Derived()" << std::endl; }
    ~Derived(){ std::cout << "~Derived()" << std::endl; }
};

int main(){
    Base *b = new Derived();
    delete b;
    return 0;
}
```

上面代码的输出结果：

```shell
Base()
Derived()
~Base()
```

没错，base class中析构函数如果不是virtual的，会有**内存泄漏**风险。

**场景1测试：**

```C++
int main(){
    Derived* d = new Derived;
    delete d;

    return 0;
}
```

输出结果：
```shell
Base()
Derived()
~Derived()
~Base()
```
通过输出结果可以看到，此时没有内存泄漏。

**场景2测试：**

```C++
int main(){
    Derived* d = new Derived;
    Base* b = d;
    d = NULL;
    delete b;

    return 0;
}
```

输出结果：

```shell
Base()
Derived()
~Base()
```

通过输出结果可以看到，base class 中的析构函数非virtual时，内存泄漏的是子类析构函数待清理的数据。

**注意**

* 多态的base class的析构函数必须声明为virtual；同理，一个类的成员函数是virtual的，析构函数必须声明为virtual。
* 类如果不具备base class特性，不该声明virtual析构函数。因为virtual函数会导致类的对象体积增加，即vptr。

### 析构函数不能抛异常

析构函数是释放资源的函数，异常发生后，可能导致资源泄漏或程序异常退出。

正确的做法是class提供普通函数，在析构前用户调用。

C\+\+11前，析构函数加 throw()声明，C\+\+11析构函数加noexcept关键字声明。

### 构造或析构过程中不能调用virtual函数

因为在构造和析构过程中，virtual函数的行为不会下沉到继承类中（即调用时那层类的virtual函数）。

### 赋值构造（operator=）的注意事项

* 返回this的引用，即return *this；扩展至 +=、-=、\*=、/=等等。

* 在operator=中”自我赋值“。涉及源对象和目标对象的地址比较、精心周到的语句顺序、以及copy-and-swap。

```C++
void swap(Class& rhs);
Widget& Widget::operator= (const Widget& rhs){
    if (this == &rhs) {return *this;}    // 认同测试，这个过程的指令效率比较低，可以不需要
    
    Widget temp(rhs);    // 为rhs数据制作一份复制（副本）
    swap(temp);    // 将*this数据和上诉复制的数据交换
    return *this;
}
```

* 复制对象时需要拷贝每个成分（成员变量）。
* 赋值构造时不能调用拷贝构造函数；同样，拷贝构造时不能调用赋值构造函数。
* 如果赋值构造函数和拷贝构造函数有相近代码时，需定义private的init函数，让他们调用。